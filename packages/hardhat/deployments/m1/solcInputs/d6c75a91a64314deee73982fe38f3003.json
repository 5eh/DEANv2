{
  "language": "Solidity",
  "sources": {
    "contracts/Commerce.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CommerceContract {\n\tstruct Product {\n\t\tstring title;\n\t\tstring description;\n\t\tstring photoURL;\n\t\tstring originsLocation;\n\t\tstring shippingMethod;\n\t\tstring upcharges;\n\t\tstring sellerName;\n\t\tuint quantity;\n\t\tuint validityTime;\n\t\tbool isAuthentic;\n\t}\n\n\tstruct Order {\n\t\taddress buyer;\n\t\tstring buyerName;\n\t\tstring deliveryLocation;\n\t\tstring shippingMethod;\n\t\tuint quantity;\n\t\tstring customInstructions;\n\t\tstring purchasedUpcharges;\n\t\tuint totalPrice;\n\t\tbool isCompleted;\n\t\tstring receiptImageURL;\n\t}\n\n\tProduct public product;\n\taddress public seller;\n\tmapping(address => Order) public orders;\n\taddress[] public buyers;\n\tuint public totalOrders;\n\tuint public productPrice;\n\n\tevent ProductListed(address seller, Product product);\n\tevent OrderPlaced(address buyer, Order order);\n\tevent OrderCompleted(address buyer, Order order);\n\n\tmodifier onlySeller() {\n\t\trequire(msg.sender == seller, \"Only seller can perform this action\");\n\t\t_;\n\t}\n\n\tmodifier validOrder() {\n\t\trequire(orders[msg.sender].buyer == address(0), \"Order already placed\");\n\t\t_;\n\t}\n\n\tconstructor(\n\t\tstring memory _title,\n\t\tstring memory _description,\n\t\tstring memory _photoURL,\n\t\tstring memory _originsLocation,\n\t\tstring memory _shippingMethod,\n\t\tstring memory _upcharges,\n\t\tstring memory _sellerName,\n\t\tuint _quantity,\n\t\tuint _validityTime,\n\t\tuint _productPrice\n\t) {\n\t\tseller = msg.sender;\n\t\tproduct = Product({\n\t\t\ttitle: _title,\n\t\t\tdescription: _description,\n\t\t\tphotoURL: _photoURL,\n\t\t\toriginsLocation: _originsLocation,\n\t\t\tshippingMethod: _shippingMethod,\n\t\t\tupcharges: _upcharges,\n\t\t\tsellerName: _sellerName,\n\t\t\tquantity: _quantity,\n\t\t\tvalidityTime: _validityTime,\n\t\t\tisAuthentic: false\n\t\t});\n\t\tproductPrice = _productPrice;\n\t\temit ProductListed(seller, product);\n\t}\n\n\tfunction placeOrder(\n\t\tstring memory _buyerName,\n\t\tstring memory _deliveryLocation,\n\t\tstring memory _shippingMethod,\n\t\tuint _quantity,\n\t\tstring memory _customInstructions,\n\t\tstring memory _purchasedUpcharges\n\t) public payable validOrder {\n\t\trequire(\n\t\t\t_quantity > 0 && _quantity <= product.quantity,\n\t\t\t\"Invalid quantity\"\n\t\t);\n\t\tuint totalPrice = calculateTotalPrice(_quantity, _purchasedUpcharges);\n\t\trequire(msg.value >= totalPrice, \"Insufficient payment\");\n\n\t\torders[msg.sender] = Order({\n\t\t\tbuyer: msg.sender,\n\t\t\tbuyerName: _buyerName,\n\t\t\tdeliveryLocation: _deliveryLocation,\n\t\t\tshippingMethod: _shippingMethod,\n\t\t\tquantity: _quantity,\n\t\t\tcustomInstructions: _customInstructions,\n\t\t\tpurchasedUpcharges: _purchasedUpcharges,\n\t\t\ttotalPrice: totalPrice,\n\t\t\tisCompleted: false,\n\t\t\treceiptImageURL: \"\"\n\t\t});\n\n\t\tbuyers.push(msg.sender);\n\t\ttotalOrders += 1;\n\t\tproduct.quantity -= _quantity;\n\n\t\temit OrderPlaced(msg.sender, orders[msg.sender]);\n\t}\n\n\tfunction completeOrder(\n\t\taddress _buyer,\n\t\tstring memory _receiptImageURL\n\t) public onlySeller {\n\t\trequire(orders[_buyer].buyer != address(0), \"Order does not exist\");\n\t\torders[_buyer].isCompleted = true;\n\t\torders[_buyer].receiptImageURL = _receiptImageURL;\n\n\t\temit OrderCompleted(_buyer, orders[_buyer]);\n\t}\n\n\tfunction calculateTotalPrice(\n\t\tuint _quantity,\n\t\tstring memory _purchasedUpcharges\n\t) internal view returns (uint) {\n\t\tuint totalPrice = _quantity * productPrice;\n\t\t// Add upcharge price logic here (e.g., each upcharge costs 0.01 ETH)\n\t\tif (bytes(_purchasedUpcharges).length > 0) {\n\t\t\ttotalPrice += 0.01 ether;\n\t\t}\n\t\treturn totalPrice;\n\t}\n\n\tfunction getOrder(address _buyer) public view returns (Order memory) {\n\t\treturn orders[_buyer];\n\t}\n\n\tfunction withdraw() public onlySeller {\n\t\trequire(totalOrders > 0, \"No orders placed\");\n\t\tbool allOrdersCompleted = true;\n\n\t\tfor (uint i = 0; i < buyers.length; i++) {\n\t\t\tif (!orders[buyers[i]].isCompleted) {\n\t\t\t\tallOrdersCompleted = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trequire(\n\t\t\tallOrdersCompleted,\n\t\t\t\"All orders must be completed before withdrawal\"\n\t\t);\n\t\tpayable(seller).transfer(address(this).balance);\n\t}\n}\n"
    },
    "contracts/CommerceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Commerce.sol\";\n\ncontract CommerceFactory {\n\taddress[] public deployedContracts;\n\n\tevent ContractDeployed(address contractAddress);\n\n\tfunction createCommerceContract(\n\t\tstring memory _title,\n\t\tstring memory _description,\n\t\tstring memory _photoURL,\n\t\tstring memory _originsLocation,\n\t\tstring memory _shippingMethod,\n\t\tstring memory _upcharges,\n\t\tstring memory _sellerName,\n\t\tuint _quantity,\n\t\tuint _validityTime,\n\t\tuint _productPrice\n\t) public {\n\t\tCommerceContract newContract = new CommerceContract(\n\t\t\t_title,\n\t\t\t_description,\n\t\t\t_photoURL,\n\t\t\t_originsLocation,\n\t\t\t_shippingMethod,\n\t\t\t_upcharges,\n\t\t\t_sellerName,\n\t\t\t_quantity,\n\t\t\t_validityTime,\n\t\t\t_productPrice\n\t\t);\n\t\tdeployedContracts.push(address(newContract));\n\t\temit ContractDeployed(address(newContract));\n\t}\n\n\tfunction getDeployedContracts() public view returns (address[] memory) {\n\t\treturn deployedContracts;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}